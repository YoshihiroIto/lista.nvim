Describe lista#matcher#fuzzy
  Before all
    let Path = vital#vital#import('System.Filepath')
    let Guard = vital#vital#import('Vim.Guard')
    let scope = themis#helper('scope')
    let sfile = Path.realpath('autoload/lista/matcher/fuzzy.vim')
    let candidates = []
    let candidates += map(range(1, 1000), '''A'' . string(v:val)')
    let candidates += map(range(1, 1000), '''a'' . string(v:val)')
    let indices = range(len(candidates))
  End

  Before
    let sf = scope.funcs(sfile)
    let guard = Guard.store(['&ignorecase'])
  End

  After
    call guard.restore()
  End

  Describe s:filter_vim()
    It filters candidates (ignorecase)
      set ignorecase
      let available_indices = sf.filter_vim(
            \ 'a105', indices, candidates
            \)
      let available_candidates = map(
            \ copy(available_indices),
            \ 'candidates[v:val]'
            \)
      Assert Equals(available_candidates, [
            \ 'A105',
            \ 'a105',
            \])
    End

    It filters candidates (noignorecase)
      set noignorecase
      let available_indices = sf.filter_vim(
            \ 'a105', indices, candidates
            \)
      let available_candidates = map(
            \ copy(available_indices),
            \ 'candidates[v:val]'
            \)
      Assert Equals(available_candidates, [
            \ 'a105',
            \])
    End
  End

  if has('lua')
    Describe s:filter_lua()
      It filters candidates (ignorecase)
        set ignorecase
        let available_indices = sf.filter_lua(
              \ 'a105', indices, candidates
              \)
        let available_candidates = map(
              \ copy(available_indices),
              \ 'candidates[v:val]'
              \)
        Assert Equals(available_candidates, [
              \ 'A105',
              \ 'a105',
              \])
      End

      It filters candidates (noignorecase)
        set noignorecase
        let available_indices = sf.filter_lua(
              \ 'a105', indices, candidates
              \)
        let available_candidates = map(
              \ copy(available_indices),
              \ 'candidates[v:val]'
              \)
        Assert Equals(available_candidates, [
              \ 'a105',
              \])
      End
    End
  endif

  if has('python')
    Describe s:filter_python()
      It filters candidates (ignorecase)
        set ignorecase
        let available_indices = sf.filter_python(
              \ 'a105', indices, candidates
              \)
        let available_candidates = map(
              \ copy(available_indices),
              \ 'candidates[v:val]'
              \)
        Assert Equals(available_candidates, [
              \ 'A105',
              \ 'a105',
              \])
      End

      It filters candidates (noignorecase)
        set noignorecase
        let available_indices = sf.filter_python(
              \ 'a105', indices, candidates
              \)
        let available_candidates = map(
              \ copy(available_indices),
              \ 'candidates[v:val]'
              \)
        Assert Equals(available_candidates, [
              \ 'a105',
              \])
      End
    End
  endif

  if has('python3')
    Describe s:filter_python3()
      It filters candidates (ignorecase)
        set ignorecase
        let available_indices = sf.filter_python3(
              \ 'a105', indices, candidates
              \)
        let available_candidates = map(
              \ copy(available_indices),
              \ 'candidates[v:val]'
              \)
        Assert Equals(available_candidates, [
              \ 'A105',
              \ 'a105',
              \])
      End

      It filters candidates (noignorecase)
        set noignorecase
        let available_indices = sf.filter_python3(
              \ 'a105', indices, candidates
              \)
        let available_candidates = map(
              \ copy(available_indices),
              \ 'candidates[v:val]'
              \)
        Assert Equals(available_candidates, [
              \ 'a105',
              \])
      End
    End
  endif
End

